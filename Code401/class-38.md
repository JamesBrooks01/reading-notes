# Reading Assignment 38

## React 2

---

### Conditional Rendering

- With React, you can have distinct components that can have conditionals for when and how they render based on the state of the app
- It works the same as in JS, with if statements of the conditional operator
- You can also store elements in variables which can help with conditional rendering where the rest of the output doesn't change.
- Use of the logical `&&` operator allows for inline if statements where if the expression on the left is true, it will render the content on the right.
- If you need an inline if/else statement, use the syntax of `condition ? true : false`.
- In the case of wanting to hide a component even if it was rendered by another component, then set the return to null instead.

---

### Lists and Keys

- You can build collections of elements with curly braces to be used in JSX
- You can also use the `map()` function to loop through an array to return a specific element for each item. This combined with curly braces allows you to render the entire array generated by `map()` in a simple code line; `<ul>{listItems}</ul>` for example.
- Usually you render lists in a component.
- When rendering list items in this manner, it is heavily recommended to have each list item have a key, which is a special string attribute that is useful for when you change, add or remove list items later.
- The keys should be a string that uniquely identifies a list item and often some part of the data will work well for the keys.
- If you don't have any other option for a stable key, you can use the index of the item in the array, but it is not reccomended.
- Keys also only make sense in the context of the array, so it should be attached to the elements in the array rather than on the `li` elements themselves.
- Keys need only be unique amongst it's sibling elements, and do not have to be globally unique.
- Finally, you can inline the map expression in curly braces and in some cases this can result in cleaner code, but it can also be abused so a good rule of thumb is that if the map body ever becomes too nested, it's a good idea to extract it to a component.

---

### Forms

- Typically, form elements like `input`, `textarea` and `select` maintain an internal state that gets updated based on user input and in React, a mutable state is usually kept in the state property of components and only updated with `setState`. 
  - To combine the two, you make the React state the single source of truth so that the React component that renders the form also controls what happens in that form based on user input.
  - The name for a component that acts this way is a "controlled component"
- When the form render is a controlled component, it requires some more code but the value can be passed to other elements or reset from other event handlers.
- In HTML, the `textarea` element defines its text by it's child elements. In React, it uses a `value` attribute instead. This way a form with a `textarea` can work similarly to a form with a single-line input.
- In HTML, `select` creates a drop-down list and the default option is specified with the `selected` attribute on an option element. In React, it replaces this attribute with a value attribute on the root `select`. This is done so that in a controlled component you only need to update it in one place.
- When you need to manage multiple inputs in a controlled component, a name attribute can be added to each and the handler function can choose what to do with each by selecting the correct one with the `event.target.name` syntax.
- By specifying the value prop in a controlled component, you can control if the user can change the input because a specified value prevents any edits. If the value is specified but still editable, it is likely it has been set to undefined or null.
- Because this React method of controlled components can be tedious, there are alternatives with uncontrolled components, an alternative way to implement an input form.

---

### Lifting State Up

- It is often the case that several components need to reflect the same changed data and in this case you should elevate the shared state to the closest common ancestor element.
- Whatever component owns the shared state and becomes to source of truth for the state for any components that use it.
- Because props are read-only, typically, once it has be elevated, the component that uses it has no control over it.
  - But, with controlled components, you can pass both the value and the function that changes it so that if the child component needs to change it, it can.
- Overall, the key things to remember are;
  - There should be a single source of truth for any data that changes in a React app and in the case of multiple components needing the same one, you elevate the state to the nearest common ancestor.
  - While it requires more code to implement it is far easier to find and fix bugs because the potential bug surface area is smaller due to a single component having control over it.
  - If something can be derived from props or state then it probably shouldn't be itself in state. In the example of temperature, they just keep the last edited one scale and the other can always be calculated based on it.

---

### Composition vs Inheritance

- React has a powerful composition model and it is recommended to use it over inheritance to reuse code between components.
- Some components don't know their child components ahead of time and this is common for Sidebar or Dialog components that represent generic boxes.
  - For these, the `children` prop is recommended for passing child elements directly into the output.
- For some components, it is though of them being special cases of other components. In React, this is achieved by composition where a more specific component renders a more generic one and configures it with props.
  - Composition works just as well for class-based components.

---

### Thinking in React

- The following steps are Facebook(now Meta)'s recommended though process for creating an app with React;
  - Start with a Mock
  1. Break the UI into a component heirarchy.
      - Draw boxes around each component in the mock and name them.
        - To decide what's a component, follow the single-responsibility principle where each component should do one thing
  2. Build a Static Version with React
      - Start off by building the app as close to the mock as you can, but hard code the data.
        - Use props for data, but reserve state for when you make it interactive
      - It is your choice if you want to work bottom-up or top-down
  3. Identify the Minimal Representation of State
      - You should think of what the minimal amount of mutable state that the app needs. Follow DRY(Don't Repeat Yourself).
  4. Identify Where the State Should Live
      - Go through the app and identify
        - Every component that renders something based on State
        - Find the common ancestor component
        - If a sensible component doesn't exist, Make One and add it in the hierarchy above the common ancestor.
  5. Add Inverse Data Flow
      - Use the correct Callbacks to update state from the form components down on the hierarchy.
